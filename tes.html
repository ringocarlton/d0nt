<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>d0nt.blinkk</title>
  <link rel="icon" href="favicon.png" type="image/png">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html, body {
      height: 100%;
      overflow: hidden;
      font-family: "Helvetica Neue", Arial, sans-serif;
      background: #000;
      color: #fff;
    }
    #canvas-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      cursor: grab;
      outline: none;
    }
    #canvas-container.grabbing {
      cursor: grabbing;
    }
    .header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px 30px;
      z-index: 100;
      pointer-events: none;
    }
    .logo {
      font-size: 24px;
      font-weight: 700;
      letter-spacing: 1px;
      text-shadow: 0 2px 10px rgba(0,0,0,0.5);
    }
    .controls {
      display: flex;
      gap: 12px;
      pointer-events: all;
    }
    .btn {
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      color: #fff;
      padding: 8px 16px;
      border-radius: 20px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s;
      backdrop-filter: blur(10px);
    }
    .btn:hover {
      background: rgba(255,255,255,0.2);
      transform: translateY(-1px);
    }
    .info-display {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      z-index: 100;
      pointer-events: none;
    }
    .cover-title {
      font-size: 22px;
      font-weight: 600;
      margin-bottom: 8px;
      opacity: 0.95;
      letter-spacing: 0.5px;
      text-shadow: 0 2px 10px rgba(0,0,0,0.8);
      transition: opacity 0.3s;
    }
    .cover-index {
      font-size: 12px;
      opacity: 0.5;
      font-weight: 300;
      text-shadow: 0 2px 8px rgba(0,0,0,0.8);
    }
    .footer {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      font-size: 11px;
      opacity: 0.4;
      z-index: 100;
      pointer-events: none;
    }
    .footer a {
      color: inherit;
      text-decoration: none;
      pointer-events: all;
    }
    .lightbox {
      display: none;
      position: fixed;
      inset: 0;
      z-index: 1000;
      background: rgba(0,0,0,0.95);
      backdrop-filter: blur(12px);
      align-items: center;
      justify-content: center;
    }
    .lightbox.visible {
      display: flex;
    }
    .lightbox-content {
      max-width: 90%;
      max-height: 90%;
      position: relative;
    }
    .lightbox-content img {
      max-width: 100%;
      max-height: 90vh;
      border-radius: 8px;
      box-shadow: 0 30px 80px rgba(0,0,0,0.8);
      display: block; /* Removes bottom spacing */
    }
    .lightbox-close {
      position: absolute;
      top: -50px;
      right: 0;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      color: #fff;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }
    .lightbox-close:hover {
      background: rgba(255,255,255,0.2);
    }
    .about-overlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.85);
      backdrop-filter: blur(8px);
      z-index: 1500;
    }
    .about-overlay.visible {
      display: flex;
    }
    .about-card {
      max-width: 500px;
      background: rgba(30,30,30,0.95);
      backdrop-filter: blur(20px);
      color: #fff;
      padding: 32px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.1);
      margin: 20px;
    }
    .about-card h3 {
      margin: 0 0 16px;
      font-size: 24px;
      font-weight: 600;
    }
    .about-card p {
      line-height: 1.6;
      opacity: 0.9;
    }
    .about-card a {
      color: #58a6ff;
      text-decoration: none;
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>

  <div class="header">
    <div class="logo">d0nt.blinkk</div>
    <div class="controls">
      <button class="btn" id="aboutBtn">About</button>
    </div>
  </div>

  <div class="info-display">
    <div class="cover-title" id="coverTitle">d0nt.blinkk</div>
    <div class="cover-index" id="coverIndex"></div>
  </div>

  <div class="footer">
    © 2026 <a href="https://instagram.com/d0nt.blinkk" target="_blank">d0nt.blinkk</a> | <a href="mailto:chorumz@gmail.com">chorumz@gmail.com</a>
  </div>

  <div class="lightbox" id="lightbox">
    <div class="lightbox-content">
      <button class="lightbox-close" id="lightboxClose">×</button>
      <img id="lightboxImg" src="" alt="">
    </div>
  </div>

  <div class="about-overlay" id="aboutOverlay">
    <div class="about-card">
      <h3>About d0nt.blinkk</h3>
      <p>d0nt.blinkk is the creative universe of Tate, a multifaceted artist exploring ideas through motion, identity and digital form.</p>
      <p style="margin-top:16px;font-size:13px;opacity:.7">Contact: <a href="mailto:chorumz@gmail.com">chorumz@gmail.com</a></p>
      <div style="text-align:right;margin-top:24px">
        <button class="btn" id="closeAbout">Close</button>
      </div>
    </div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';

    let images = [];
    let scene, camera, renderer;
    let coverMeshes = [];
    let currentRotation = 0;
    let targetRotation = 0;
    let velocity = 0;
    let isDragging = false;
    let previousMouseX = 0;
    let textureLoader = new THREE.TextureLoader();
    
    const container = document.getElementById('canvas-container');
    const coverTitle = document.getElementById('coverTitle');
    const coverIndex = document.getElementById('coverIndex');
    const lightbox = document.getElementById('lightbox');
    const lightboxImg = document.getElementById('lightboxImg');

    // CONFIGURATION
    const RADIUS = 9; 
    const BASE_HEIGHT = 4.5; // Max height of an image in world units
    
    // Load images
    fetch('images.json')
      .then(r => r.json())
      .then(data => {
        images = data;
        init();
        animate();
      })
      .catch(err => {
        console.error('Failed to load images:', err);
        // Fallback for testing if json fails
        images = ['placeholder.jpg', 'placeholder.jpg', 'placeholder.jpg', 'placeholder.jpg', 'placeholder.jpg'];
        init();
        animate();
      });

    function init() {
      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x050505);
      
      // Fog for depth fading
      scene.fog = new THREE.FogExp2(0x050505, 0.04);

      // Camera
      camera = new THREE.PerspectiveCamera(
        45, // Slightly narrower FOV for less distortion
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 0, 16);
      camera.lookAt(0, 0, 0);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      container.appendChild(renderer.domElement);

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(0, 10, 10);
      scene.add(directionalLight);
      
      const pointLight = new THREE.PointLight(0x58a6ff, 0.5, 20);
      pointLight.position.set(0, 0, 10);
      scene.add(pointLight);

      // Create covers
      createCovers();

      // Event listeners
      setupEventListeners();

      // Update display
      updateDisplay();
    }

    function createCovers() {
      const angleStep = (Math.PI * 2) / images.length;

      images.forEach((filename, index) => {
        // Use a 1x1 geometry so we can scale it perfectly to any aspect ratio later
        const geometry = new THREE.PlaneGeometry(1, 1);
        
        // Initial Aspect Ratio (Square fallback)
        let aspectRatio = 1.0; 

        // Load texture with callback to get dimensions
        const texture = textureLoader.load(`images/${filename}`, (tex) => {
            // Once loaded, calculate real aspect ratio
            if(tex.image.width && tex.image.height) {
                aspectRatio = tex.image.width / tex.image.height;
                mesh.userData.aspectRatio = aspectRatio; // Store it on mesh
            }
        });

        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        texture.colorSpace = THREE.SRGBColorSpace;
        
        const material = new THREE.MeshStandardMaterial({
          map: texture,
          side: THREE.DoubleSide,
          metalness: 0.1,
          roughness: 0.4
        });

        const mesh = new THREE.Mesh(geometry, material);
        
        // Store metadata
        mesh.userData = { 
            index, 
            filename, 
            baseAngle: index * angleStep,
            aspectRatio: 1.0 // Default, updated when texture loads
        };
        
        scene.add(mesh);
        coverMeshes.push(mesh);
      });
    }

    function setupEventListeners() {
      // Mouse events
      container.addEventListener('mousedown', (e) => {
        isDragging = true;
        previousMouseX = e.clientX;
        velocity = 0;
        container.classList.add('grabbing');
      });

      window.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        
        const deltaX = e.clientX - previousMouseX;
        const sensitivity = 0.003;
        
        targetRotation += deltaX * sensitivity;
        velocity = deltaX * sensitivity;
        
        previousMouseX = e.clientX;
      });

      window.addEventListener('mouseup', () => {
        if (!isDragging) return;
        isDragging = false;
        container.classList.remove('grabbing');
        snapToNearest();
      });

      // Touch events
      let previousTouchX = 0;

      container.addEventListener('touchstart', (e) => {
        isDragging = true;
        previousTouchX = e.touches[0].clientX;
        velocity = 0;
      });

      container.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        
        const deltaX = e.touches[0].clientX - previousTouchX;
        const sensitivity = 0.005;
        
        targetRotation += deltaX * sensitivity;
        velocity = deltaX * sensitivity;
        
        previousTouchX = e.touches[0].clientX;
      });

      container.addEventListener('touchend', () => {
        if (!isDragging) return;
        isDragging = false;
        snapToNearest();
      });

      // Wheel event
      let wheelTimeout;
      container.addEventListener('wheel', (e) => {
        e.preventDefault();
        
        const delta = e.deltaY;
        const sensitivity = 0.001;
        
        targetRotation += delta * sensitivity;
        
        clearTimeout(wheelTimeout);
        wheelTimeout = setTimeout(snapToNearest, 100);
      }, { passive: false });

      // Keyboard
      document.addEventListener('keydown', (e) => {
        if (lightbox.classList.contains('visible')) {
          if (e.key === 'Escape') lightbox.classList.remove('visible');
          return;
        }
        
        const angleStep = (Math.PI * 2) / images.length;
        
        if (e.key === 'ArrowLeft') {
          targetRotation += angleStep;
          snapToNearest();
        } else if (e.key === 'ArrowRight') {
          targetRotation -= angleStep;
          snapToNearest();
        } else if (e.key === 'Enter' || e.key === ' ') {
          const centerIndex = getCurrentCenterIndex();
          showLightbox(centerIndex);
        }
      });

      // Click on cover
      container.addEventListener('click', (e) => {
        if (Math.abs(velocity) > 0.01) return;
        
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(coverMeshes);
        
        if (intersects.length > 0) {
          const clickedMesh = intersects[0].object;
          const clickedIndex = clickedMesh.userData.index;
          const centerIndex = getCurrentCenterIndex();
          
          if (clickedIndex === centerIndex) {
            showLightbox(clickedIndex);
          } else {
            // Calculate shortest path to rotation
            const angleStep = (Math.PI * 2) / images.length;
            let diff = clickedIndex - centerIndex;
            
            // Optimize path across the wrap-around point
            if (Math.abs(diff) > images.length / 2) {
                diff = diff > 0 ? diff - images.length : diff + images.length;
            }
            
            targetRotation -= diff * angleStep;
          }
        }
      });

      // Window resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    function snapToNearest() {
        const angleStep = (Math.PI * 2) / images.length;
        const targetIndex = Math.round(targetRotation / angleStep);
        targetRotation = targetIndex * angleStep;
    }

    function animate() {
      requestAnimationFrame(animate);

      // Smooth rotation with easing
      if (!isDragging) {
        const diff = targetRotation - currentRotation;
        currentRotation += diff * 0.1;
        velocity *= 0.9;
      }

      // Update cover positions and rotations
      coverMeshes.forEach((mesh) => {
        const baseAngle = mesh.userData.baseAngle;
        const angle = baseAngle + currentRotation;
        
        const x = Math.sin(angle) * RADIUS;
        const z = Math.cos(angle) * RADIUS;
        
        mesh.position.set(x, 0, z);
        
        // Simplified Rotation: Just face the center (0,0,0)
        // This removes the "wonky" tilt effect
        mesh.lookAt(0, 0, 0);
        
        // Scale logic to preserve aspect ratio
        // We scale based on distance (closer = bigger)
        // Normalized Z goes from -Radius to +Radius
        // +Radius is close to camera, -Radius is far
        
        const scaleFactor = 1.0; 
        
        // Calculate dynamic dimensions based on aspect ratio
        const ar = mesh.userData.aspectRatio;
        
        // We fix the HEIGHT, and let WIDTH adjust
        // If image is portrait (ar < 1), height is BASE_HEIGHT
        // If image is landscape (ar > 1), we might want to cap width instead?
        // Let's stick to fixing height for a clean gallery feel
        
        mesh.scale.y = BASE_HEIGHT * scaleFactor;
        mesh.scale.x = (BASE_HEIGHT * ar) * scaleFactor;

        // Opacity/Fade based on depth
        // normalize z from -RADIUS to RADIUS into 0 to 1
        const depth = (z + RADIUS) / (RADIUS * 2);
        // ease the opacity
        const opacity = Math.pow(depth, 3); // sharper falloff
        
        mesh.material.opacity = Math.max(0.1, opacity);
        mesh.material.transparent = true;
      });

      updateDisplay();
      renderer.render(scene, camera);
    }

    function getCurrentCenterIndex() {
      const angleStep = (Math.PI * 2) / images.length;
      const rawIndex = -Math.round(currentRotation / angleStep);
      return ((rawIndex % images.length) + images.length) % images.length;
    }

    function updateDisplay() {
      const centerIndex = getCurrentCenterIndex();
      if(images.length > 0) {
        const filename = images[centerIndex];
        if (filename) {
          coverTitle.textContent = filename.replace(/\.[^/.]+$/, '');
          coverIndex.textContent = `${centerIndex + 1} of ${images.length}`;
        }
      }
    }

    function showLightbox(index) {
      if(images[index]) {
        lightboxImg.src = `images/${images[index]}`;
        lightbox.classList.add('visible');
      }
    }

    // Lightbox controls
    document.getElementById('lightboxClose').addEventListener('click', () => {
      lightbox.classList.remove('visible');
    });

    lightbox.addEventListener('click', (e) => {
      if (e.target === lightbox) {
        lightbox.classList.remove('visible');
      }
    });

    // About modal
    document.getElementById('aboutBtn').addEventListener('click', () => {
      document.getElementById('aboutOverlay').classList.add('visible');
    });

    document.getElementById('closeAbout').addEventListener('click', () => {
      document.getElementById('aboutOverlay').classList.remove('visible');
    });

    document.getElementById('aboutOverlay').addEventListener('click', (e) => {
      if (e.target.id === 'aboutOverlay') {
        e.target.classList.remove('visible');
      }
    });
  </script>
</body>
</html>
