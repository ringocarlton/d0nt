<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>d0nt.blinkk</title>
  <link rel="icon" href="favicon.png" type="image/png">
  <style>
    /* --- RESET & BASICS --- */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      height: 100%;
      overflow: hidden;
      font-family: "Helvetica Neue", Arial, sans-serif;
      background: #050505;
      color: #fff;
      -webkit-font-smoothing: antialiased;
    }

    /* --- GALLERY CONTAINER --- */
    .gallery {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: grab;
      z-index: 10;
      perspective: 1000px; /* Adds subtle depth */
    }
    .gallery.grabbing {
      cursor: grabbing;
    }

    /* --- THE CARDS LIST --- */
    /* We use the structure you asked for */
    ul.cards {
      list-style: none;
      width: 100%;
      height: 60vh; /* Adjust height of the carousel area */
      position: relative;
      display: flex;
      align-items: center;
      /* We don't use overflow-x: scroll because we are doing custom infinite logic */
    }

    /* --- INDIVIDUAL CARD ITEMS --- */
    ul.cards li {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 35vh; /* Card width based on viewport height for responsiveness */
      height: 50vh; /* Card height */
      transform: translate3d(-50%, -50%, 0); /* Center pivot */
      will-change: transform, opacity;
      transform-style: preserve-3d;
    }

    /* --- IMAGES --- */
    ul.cards li img {
      width: 100%;
      height: 100%;
      object-fit: cover; /* Ensures images fill the card without stretching */
      border-radius: 8px;
      box-shadow: 0 15px 50px rgba(0,0,0,0.5);
      pointer-events: none; /* Prevents native image drag */
      display: block;
      background: #1a1a1a; /* Placeholder color while loading */
    }

    /* --- UI OVERLAYS (Header, Footer, etc) --- */
    .header {
      position: fixed;
      top: 0; left: 0; right: 0;
      display: flex; justify-content: space-between; align-items: center;
      padding: 20px 30px;
      z-index: 100; pointer-events: none;
    }
    .logo {
      font-size: 24px; font-weight: 700; letter-spacing: 1px;
      text-shadow: 0 2px 10px rgba(0,0,0,0.5);
    }
    .controls { pointer-events: all; }
    .btn {
      background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2);
      color: #fff; padding: 8px 16px; border-radius: 20px;
      cursor: pointer; font-size: 12px; transition: all 0.2s;
      backdrop-filter: blur(10px);
    }
    .btn:hover { background: rgba(255,255,255,0.2); transform: translateY(-1px); }

    .info-display {
      position: fixed; bottom: 80px; left: 50%;
      transform: translateX(-50%); text-align: center;
      z-index: 100; pointer-events: none;
    }
    .cover-title {
      font-size: 22px; font-weight: 600; margin-bottom: 8px; opacity: 0.95;
      text-shadow: 0 2px 10px rgba(0,0,0,0.8);
    }
    .cover-index { font-size: 12px; opacity: 0.5; font-weight: 300; }

    .footer {
      position: fixed; bottom: 20px; left: 50%;
      transform: translateX(-50%); text-align: center;
      font-size: 11px; opacity: 0.4; z-index: 100; pointer-events: none;
    }
    .footer a { color: inherit; text-decoration: none; pointer-events: all; }

    /* --- LIGHTBOX --- */
    .lightbox {
      display: none; position: fixed; inset: 0; z-index: 1000;
      background: rgba(0,0,0,0.95); backdrop-filter: blur(12px);
      align-items: center; justify-content: center;
    }
    .lightbox.visible { display: flex; }
    .lightbox-content { max-width: 90%; max-height: 90%; position: relative; }
    .lightbox-content img {
      max-width: 100%; max-height: 90vh;
      border-radius: 4px; box-shadow: 0 20px 60px rgba(0,0,0,0.8);
    }
    .lightbox-close {
      position: absolute; top: -50px; right: 0;
      background: transparent; border: none; color: #fff;
      font-size: 30px; cursor: pointer; opacity: 0.7;
    }
    
    /* --- ABOUT OVERLAY --- */
    .about-overlay {
      position: fixed; inset: 0; display: none;
      align-items: center; justify-content: center;
      background: rgba(0,0,0,0.85); backdrop-filter: blur(8px);
      z-index: 1500;
    }
    .about-overlay.visible { display: flex; }
    .about-card {
      max-width: 400px; background: #111; color: #fff;
      padding: 30px; border-radius: 12px; border: 1px solid #333;
    }
    .about-card h3 { margin-bottom: 15px; }
    .about-card p { font-size: 14px; line-height: 1.5; color: #ccc; }
  </style>
</head>
<body>

  <div class="gallery" id="gallery">
    <ul class="cards" id="cards-container">
        </ul>
  </div>

  <div class="header">
    <div class="logo">d0nt.blinkk</div>
    <div class="controls"><button class="btn" id="aboutBtn">About</button></div>
  </div>

  <div class="info-display">
    <div class="cover-title" id="coverTitle">Loading...</div>
    <div class="cover-index" id="coverIndex"></div>
  </div>

  <div class="footer">
    © 2026 <a href="https://instagram.com/d0nt.blinkk" target="_blank">d0nt.blinkk</a>
  </div>

  <div class="lightbox" id="lightbox">
    <div class="lightbox-content">
      <button class="lightbox-close" id="lightboxClose">×</button>
      <img id="lightboxImg" src="" alt="">
    </div>
  </div>

  <div class="about-overlay" id="aboutOverlay">
    <div class="about-card">
      <h3>About</h3>
      <p>d0nt.blinkk is the creative universe of Tate.</p>
      <div style="margin-top:20px;text-align:right"><button class="btn" id="closeAbout">Close</button></div>
    </div>
  </div>

  <script>
    // --- CONFIGURATION ---
    const CONFIG = {
      sensitivity: 1.5, // Drag speed
      friction: 0.95,   // How quickly it slows down (0-1)
      gap: 50,          // Gap between cards (in px, though we calculate dynamically)
      scaleSpread: 0.4, // How much side cards shrink
      opacitySpread: 0.5 // How much side cards fade
    };

    // --- STATE ---
    let images = [];
    let items = []; // Holds the DOM elements
    let scrollPos = 0;
    let targetScrollPos = 0;
    let isDragging = false;
    let startX = 0;
    let lastX = 0;
    let velocity = 0;
    let rafId;
    let cardWidth = 0;
    let totalWidth = 0;
    
    // --- DOM ELEMENTS ---
    const container = document.getElementById('cards-container');
    const gallery = document.getElementById('gallery');
    const titleEl = document.getElementById('coverTitle');
    const indexEl = document.getElementById('coverIndex');
    const lightbox = document.getElementById('lightbox');
    const lightboxImg = document.getElementById('lightboxImg');

    // --- INIT ---
    fetch('images.json')
      .then(r => r.json())
      .then(data => {
        images = data;
        initGallery();
        animate();
      })
      .catch(() => {
        // Fallback
        images = ['placeholder.jpg', 'placeholder.jpg', 'placeholder.jpg', 'placeholder.jpg'];
        initGallery();
        animate();
      });

    function initGallery() {
      container.innerHTML = '';
      items = [];

      // Create List Items
      images.forEach((src, i) => {
        const li = document.createElement('li');
        const img = document.createElement('img');
        
        img.src = `images/${src}`;
        img.draggable = false;
        img.alt = "Album cover";
        
        li.appendChild(img);
        container.appendChild(li);
        
        // Store reference and data
        items.push({
          el: li,
          index: i,
          title: src.replace(/\.[^/.]+$/, '') // Remove extension
        });
        
        // Click to center or open lightbox
        li.addEventListener('click', () => handleClick(i));
      });

      // Calculate initial dimensions
      updateDimensions();
      window.addEventListener('resize', updateDimensions);
    }

    function updateDimensions() {
      // Get the width of one card (based on CSS)
      if(items.length > 0) {
        cardWidth = items[0].el.offsetWidth + CONFIG.gap;
        totalWidth = cardWidth * items.length;
      }
    }

    // --- INTERACTION HANDLERS ---
    
    // Mouse / Touch Start
    const onStart = (x) => {
      isDragging = true;
      startX = x;
      lastX = x;
      velocity = 0;
      gallery.classList.add('grabbing');
      cancelAnimationFrame(rafId); // Stop inertia while grabbing
      animate(); // Restart loop
    };

    // Mouse / Touch Move
    const onMove = (x) => {
      if (!isDragging) return;
      const delta = x - lastX;
      targetScrollPos += delta * CONFIG.sensitivity;
      velocity = delta * CONFIG.sensitivity;
      lastX = x;
    };

    // Mouse / Touch End
    const onEnd = () => {
      isDragging = false;
      gallery.classList.remove('grabbing');
    };

    // Listeners
    gallery.addEventListener('mousedown', e => onStart(e.clientX));
    window.addEventListener('mousemove', e => onMove(e.clientX));
    window.addEventListener('mouseup', onEnd);

    gallery.addEventListener('touchstart', e => onStart(e.touches[0].clientX));
    window.addEventListener('touchmove', e => onMove(e.touches[0].clientX));
    window.addEventListener('touchend', onEnd);

    // Wheel
    gallery.addEventListener('wheel', e => {
      e.preventDefault();
      targetScrollPos -= e.deltaY * 0.5;
    }, { passive: false });

    // --- ANIMATION LOOP ---
    function animate() {
      // 1. Physics: Smooth dragging and inertia
      if (!isDragging) {
        targetScrollPos += velocity;
        velocity *= CONFIG.friction;
        
        // Snap to center when almost stopped
        if (Math.abs(velocity) < 0.1 && Math.abs(velocity) > 0) {
           const nearestIndex = Math.round(targetScrollPos / cardWidth);
           const snapPos = nearestIndex * cardWidth;
           // Ease to snap
           targetScrollPos += (snapPos - targetScrollPos) * 0.1;
        }
      }
      
      // Smooth interpolation for visual scroll
      scrollPos += (targetScrollPos - scrollPos) * 0.1;

      // 2. Render Items
      const centerX = window.innerWidth / 2;
      
      let centerItemIndex = 0;
      let minDist = Infinity;

      items.forEach((item, i) => {
        // Calculate "Infinite" Position
        // We use modulo to wrap positions around
        const itemOffset = i * cardWidth; // Original position
        
        // Relative position including scroll
        let relativePos = (itemOffset + scrollPos) % totalWidth;
        
        // Wrap logic: If it goes too far right, move to left, and vice versa
        while (relativePos > totalWidth / 2) relativePos -= totalWidth;
        while (relativePos < -totalWidth / 2) relativePos += totalWidth;

        // Visual properties based on distance from center
        const distance = Math.abs(relativePos);
        const normalize = Math.max(0, 1 - distance / (window.innerWidth * 0.6)); // 0 to 1 based on distance
        
        // Scale and Opacity
        const scale = 1 - (1 - normalize) * CONFIG.scaleSpread;
        const opacity = 1 - (1 - normalize) * CONFIG.opacitySpread;
        const zIndex = Math.round(normalize * 100);

        // Apply styles
        item.el.style.transform = `translate3d(${relativePos}px, -50%, 0) scale(${scale})`;
        item.el.style.opacity = opacity;
        item.el.style.zIndex = zIndex;

        // Find which item is closest to center for the title
        if (distance < minDist) {
          minDist = distance;
          centerItemIndex = i;
        }
      });

      // 3. Update Text UI
      if(items.length > 0) {
        const activeItem = items[centerItemIndex];
        titleEl.textContent = activeItem.title;
        indexEl.textContent = `${activeItem.index + 1} of ${items.length}`;
      }

      rafId = requestAnimationFrame(animate);
    }

    // --- CLICK HANDLING ---
    function handleClick(index) {
      if (Math.abs(velocity) > 1) return; // Ignore clicks while swiping fast

      // Find where this item is currently visualised relative to center
      // If it's the center item, open lightbox. If side, scroll to it.
      
      // We calculate the shortest distance to snap this index to center
      // Since our scrollPos is technically infinite, we find the closest multiple
      
      const currentCycle = Math.round(targetScrollPos / totalWidth);
      const idealPos = -(index * cardWidth) + (currentCycle * totalWidth);
      
      // Check if we should wrap around (is it closer to go left or right?)
      // This is a simple approximation; for a perfect one we'd check neighbors
      const centerItem = document.elementFromPoint(window.innerWidth/2, window.innerHeight/2);
      
      // Simple check: Is this the centered item?
      // We compare the text content or use a class. 
      // Let's rely on the visual calculation we did in the loop.
      if (titleEl.textContent === items[index].title) {
         openLightbox(index);
      } else {
         // Scroll to it
         // Note: Implementing perfect "shortest path" scrolling in a modulo 
         // system is complex. A simple trick is to just push the targetScrollPos.
         // A hacky way: check the item's current transform X value.
         const style = window.getComputedStyle(items[index].el);
         const matrix = new DOMMatrix(style.transform);
         const currentVisualX = matrix.m41; // Translate X
         
         targetScrollPos -= currentVisualX; // Move by the difference
      }
    }

    // --- LIGHTBOX ---
    function openLightbox(index) {
      lightboxImg.src = `images/${images[index]}`;
      lightbox.classList.add('visible');
    }

    document.getElementById('lightboxClose').addEventListener('click', () => {
      lightbox.classList.remove('visible');
    });
    lightbox.addEventListener('click', (e) => {
      if(e.target === lightbox) lightbox.classList.remove('visible');
    });

    // --- ABOUT ---
    document.getElementById('aboutBtn').addEventListener('click', () => {
      document.getElementById('aboutOverlay').classList.add('visible');
    });
    document.getElementById('closeAbout').addEventListener('click', () => {
      document.getElementById('aboutOverlay').classList.remove('visible');
    });
    document.getElementById('aboutOverlay').addEventListener('click', (e) => {
      if(e.target === document.getElementById('aboutOverlay')) 
        e.target.classList.remove('visible');
    });
  </script>
</body>
</html>
